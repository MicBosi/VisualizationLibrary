/**************************************************************************************/
/*                                                                                    */
/*  Visualization Library                                                             */
/*  http://www.visualizationlibrary.com                                               */
/*                                                                                    */
/*  Copyright (c) 2005-2010, Michele Bosi                                             */
/*  All rights reserved.                                                              */
/*                                                                                    */
/*  Redistribution and use in source and binary forms, with or without modification,  */
/*  are permitted provided that the following conditions are met:                     */
/*                                                                                    */
/*  - Redistributions of source code must retain the above copyright notice, this     */
/*  list of conditions and the following disclaimer.                                  */
/*                                                                                    */
/*  - Redistributions in binary form must reproduce the above copyright notice, this  */
/*  list of conditions and the following disclaimer in the documentation and/or       */
/*  other materials provided with the distribution.                                   */
/*                                                                                    */
/*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND   */
/*  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED     */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE            */
/*  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR  */
/*  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    */
/*  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;      */
/*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON    */
/*  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT           */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS     */
/*  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                      */
/*                                                                                    */
/**************************************************************************************/

#ifndef VectorGraphics_INCLUDE_ONCE
#define VectorGraphics_INCLUDE_ONCE

#include <vl/Image.hpp>
#include <vl/Text.hpp>
#include <vl/Effect.hpp>
#include <vl/SceneManager.hpp>
#include <vl/Clear.hpp>
#include <vl/Scissor.hpp>

namespace vlVG
{
  //! Defines how the texture is applied to the rendering primitive
  typedef enum
  {
    //! The texture is stretched over the primitive
    TextureMode_Clamp,
    //! The texture is repeated over the primitive
    TextureMode_Repeat
  } ETextureMode;

  //! Poligon stipple patterns
  typedef enum
  {
    //! The poligon is completely filled (default)
    PolygonStipple_Solid,
    PolygonStipple_Dot,
    PolygonStipple_Chain,
    PolygonStipple_HLine,
    PolygonStipple_VLine
  } EPolygonStipple;

  //! Line stipple patterns
  typedef enum
  {
    //! The line is completely filled  (default)
    LineStipple_Solid,
    LineStipple_Dot,
    LineStipple_Dash,
    LineStipple_Dash4,
    LineStipple_Dash8,
    LineStipple_DashDot,
    LineStipple_DashDotDot
  } ELineStipple;

//-------------------------------------------------------------------------------------------------------------------------------------------
// VectorGraphics
//-------------------------------------------------------------------------------------------------------------------------------------------
  /**
   * The VectorGraphics class is used in conjuction with SceneManagerVectorGraphics to generate and render 2D vector graphics.
   * The VectorGraphics object is basically nothing more than an container of Actor[s] generated by functions like
   * drawLines(), fillTriangles() etc. The Actor[s] are rendered in the order in which they are generated. 
   *
   * The VectorGraphics class features a set of advanced capabilites:
   * - Matrix transformations and matrix stack
   * - State stack
   * - All the blending operations supported by OpenGL
   * - All the stencil operations supported by OpenGL
   * - Texture mapping on all the primitives with automatic texture coordinate generation
   * - Several primitives like lines, points, quads, triangles, line strips, triangle strips, ellipses etc.
   * - Polygon and line stipple
   * - Text rendering
   * - Scissor test to clip the objects against a rectangular region
   * - Line and point smoothing
   * - Color logic operations
   *
   * For more information please refer to the \ref pagGuideVectorGraphics "2D Vector Graphics" page.
   */
  class VectorGraphics: public vl::Object
  {
  private:
    //------------------------------------------------------------------------- start internal
    //! \internal
    class ImageState
    {
    public:
      ImageState(vl::Image* img, ETextureMode mode): mImage(img), mTextureMode(mode) {}

      bool operator<(const ImageState& other) const
      {
        if (mImage != other.mImage)
          return mImage < other.mImage;
        else
        if (mTextureMode != other.mTextureMode)
          return mTextureMode < other.mTextureMode;
        else
          return false;
      }
    protected:
      vl::Image* mImage;
      ETextureMode mTextureMode;
    };
    //------------------------------------------------------------------------- start internal
    //! \internal
    class State
    {
    public:
      State()
      {
        mColor         = vlut::white;
        mPointSize     = 5;
        mImage         = NULL;
        mTextureMode   = TextureMode_Clamp;
        mLogicOp       = vl::LO_COPY;
        mPointSmoothing= true;
        mLineSmoothing = true;
        mPolygonSmoothing = false;
        mLineWidth     = 1.0;
        mLineStipple   = 0xFFFF;
        memset(mPolyStipple, 0xFF, 32*32/8);

        // blend equation
        mBlendEquationRGB    = vl::BE_FUNC_ADD;
        mBlendEquationAlpha  = vl::BE_FUNC_ADD;
        // blend factor
        mBlendFactorSrcRGB   = vl::BF_SRC_ALPHA;
        mBlendFactorDstRGB   = vl::BF_ONE_MINUS_SRC_ALPHA;
        mBlendFactorSrcAlpha = vl::BF_SRC_ALPHA;
        mBlendFactorDstAlpha = vl::BF_ONE_MINUS_SRC_ALPHA;
        // alpha func
        mAlphaFuncRefValue = 0.0f;
        mAlphaFunc         = vl::FU_ALWAYS;
        // font
        mFont              = vl::VisualizationLibrary::fontManager()->acquireFont("/font/bitstream-vera/VeraMono.ttf", 10, false);
        // masks
        /*mDepthMask   = true;*/
        mColorMask   = vl::ivec4(1,1,1,1);
        // stencil
        mStencilMask = 0xFFFFFFFF;
        mStencilTestEnabled = false;
        mStencil_SFail  = vl::SO_KEEP;
        mStencil_SFail  = vl::SO_KEEP;
        mStencil_DpFail = vl::SO_KEEP;
        mStencil_Function = vl::FU_ALWAYS;
        mStencil_RefValue = 0;
        mStencil_FunctionMask = ~(unsigned int)0;
      }

      vl::fvec4 mColor;
      int mPointSize;
      vl::ref<vl::Image> mImage;
      ETextureMode mTextureMode;
      vl::ELogicOp mLogicOp;
      float mLineWidth;
      bool mPointSmoothing;
      bool mLineSmoothing;
      bool mPolygonSmoothing;
      unsigned short mLineStipple;
      unsigned char mPolyStipple[32*32/8];
      vl::EBlendEquation mBlendEquationRGB;
      vl::EBlendEquation mBlendEquationAlpha;
      vl::EBlendFactor mBlendFactorSrcRGB;
      vl::EBlendFactor mBlendFactorDstRGB;
      vl::EBlendFactor mBlendFactorSrcAlpha;
      vl::EBlendFactor mBlendFactorDstAlpha;
      float mAlphaFuncRefValue;
      vl::EFunction mAlphaFunc;
      vl::ref<vl::Font> mFont;
      /*bool mDepthMask;*/
      vl::ivec4 mColorMask;
      // stencil
      bool mStencilTestEnabled;
      unsigned int mStencilMask;
      vl::EStencilOp mStencil_SFail;
      vl::EStencilOp mStencil_DpFail;
      vl::EStencilOp mStencil_DpPass;
      vl::EFunction  mStencil_Function;
      int          mStencil_RefValue;
      unsigned int         mStencil_FunctionMask;

      bool operator<(const State& other) const
      {
        // lexicographic sorting
        if (mColor.r() != other.mColor.r())
          return mColor.r() < other.mColor.r();
        else
        if (mColor.g() != other.mColor.g())
          return mColor.g() < other.mColor.g();
        else
        if (mColor.b() != other.mColor.b())
          return mColor.b() < other.mColor.b();
        else
        if (mColor.a() != other.mColor.a())
          return mColor.a() < other.mColor.a();
        else
        if(mPointSize != other.mPointSize)
          return mPointSize < other.mPointSize;
        else
        if(mImage != other.mImage)
          return mImage < other.mImage;
        else
        if (mTextureMode != other.mTextureMode)
          return mTextureMode < other.mTextureMode;
        else
        if (mPolygonSmoothing != other.mPolygonSmoothing)
          return mPolygonSmoothing < other.mPolygonSmoothing;
        else
        if (mPointSmoothing!= other.mPointSmoothing)
          return mPointSmoothing < other.mPointSmoothing;
        else
        if (mLineSmoothing!= other.mLineSmoothing)
          return mLineSmoothing < other.mLineSmoothing;
        else
        if (mLineWidth != other.mLineWidth)
          return mLineWidth < other.mLineWidth;
        else
        if (mLineStipple != other.mLineStipple)
          return mLineStipple < other.mLineStipple;
        else
        if (mLogicOp != other.mLogicOp)
          return mLogicOp < other.mLogicOp;
        else
        if ( memcmp(mPolyStipple, other.mPolyStipple, 32*32/8) != 0 )
          return memcmp(mPolyStipple, other.mPolyStipple, 32*32/8) < 0;
        else
        if ( mBlendEquationRGB != other.mBlendEquationRGB)
          return mBlendEquationRGB < other.mBlendEquationRGB;
        else
        if ( mBlendEquationAlpha != other.mBlendEquationAlpha)
          return mBlendEquationAlpha < other.mBlendEquationAlpha;
        else
        if ( mBlendFactorSrcRGB != other.mBlendFactorSrcRGB)
          return mBlendFactorSrcRGB < other.mBlendFactorSrcRGB;
        else
        if ( mBlendFactorDstRGB != other.mBlendFactorDstRGB)
          return mBlendFactorDstRGB < other.mBlendFactorDstRGB;
        else
        if ( mBlendFactorSrcAlpha != other.mBlendFactorSrcAlpha)
          return mBlendFactorSrcAlpha < other.mBlendFactorSrcAlpha;
        else
        if ( mBlendFactorDstAlpha != other.mBlendFactorDstAlpha)
          return mBlendFactorDstAlpha < other.mBlendFactorDstAlpha;
        else
        if ( mAlphaFuncRefValue != other.mAlphaFuncRefValue)
          return mAlphaFuncRefValue < other.mAlphaFuncRefValue;
        else
        if ( mAlphaFunc != other.mAlphaFunc)
          return mAlphaFunc < other.mAlphaFunc;
        else
        if ( mFont != other.mFont)
          return mFont < other.mFont;
        else
        /*if ( mDepthMask != other.mDepthMask)
          return mDepthMask < other.mDepthMask;
        else*/
        if ( mColorMask.r() != other.mColorMask.r())
          return mColorMask.r() < other.mColorMask.r();
        else
        if ( mColorMask.g() != other.mColorMask.g())
          return mColorMask.g() < other.mColorMask.g();
        else
        if ( mColorMask.b() != other.mColorMask.b())
          return mColorMask.b() < other.mColorMask.b();
        else
        if ( mColorMask.a() != other.mColorMask.a())
          return mColorMask.a() < other.mColorMask.a();
        else
        if ( mStencilMask != other.mStencilMask)
          return mStencilMask < other.mStencilMask;
        else
        if ( mStencilTestEnabled != other.mStencilTestEnabled)
          return mStencilTestEnabled < other.mStencilTestEnabled;
        else
        if ( mStencil_SFail != other.mStencil_SFail )
          return mStencil_SFail < other.mStencil_SFail;
        else
        if ( mStencil_DpFail != other.mStencil_DpFail )
          return mStencil_DpFail < other.mStencil_DpFail;
        else
        if ( mStencil_DpPass != other.mStencil_DpPass )
          return mStencil_DpPass < other.mStencil_DpPass;
        else
        if ( mStencil_Function != other.mStencil_Function )
          return mStencil_Function < other.mStencil_Function;
        else
        if ( mStencil_RefValue != other.mStencil_RefValue )
          return mStencil_RefValue < other.mStencil_RefValue;
        else
        if ( mStencil_FunctionMask != other.mStencil_FunctionMask )
          return mStencil_FunctionMask < other.mStencil_FunctionMask;
        else
          return false;
      }
    };
    //------------------------------------------------------------------------- end internal

  public:
    virtual const char* className() { return "VectorGraphics"; }
    VectorGraphics()
    {
      mDefaultEffect = new vl::Effect;
      mDefaultEffect->shader()->enable(vl::EN_BLEND);
      mActors.setAutomaticDelete(false);
    }

    //! Returns the list of Actor[s] generated by a VectorGraphics object.
    const vl::ActorCollection* actors() const { return &mActors; }
    //! Returns the list of Actor[s] generated by a VectorGraphics object.
    vl::ActorCollection* actors() { return &mActors; }
    //! Renders a line starting a point <x1,y1> and ending at point <x2,y2>
    vl::Actor* drawLine(double x1, double y1, double x2, double y2)
    {
      std::vector<vl::dvec2> ln;
      ln.push_back(vl::dvec2(x1,y1));
      ln.push_back(vl::dvec2(x2,y2));
      return drawLines(ln);
    }
    //! Renders a set of lines. The 'ln' parameter shoud contain N pairs of vl::dvec2. Each pair defines a line segment.
    vl::Actor* drawLines(const std::vector<vl::dvec2>& ln)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(ln);
      // generate texture coords
      if (mState.mImage)
      {
        vl::ref<vl::ArrayFloat> tex_array = new vl::ArrayFloat;
        tex_array->resize(geom->vertexArray()->size());
        float u1 = 1.0f / mState.mImage->width() * 0.5f;
        float u2 = 1.0f - 1.0f / mState.mImage->width() * 0.5f;
        for(size_t i=0; i<tex_array->size(); i+=2)
        {
          tex_array->at(i+0) = u1;
          tex_array->at(i+1) = u2;
        }
        // generate geometry
        geom->setTexCoordArray(0, tex_array.get());
      }
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_LINES, 0, ln.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a line passing through the points defined by 'ln'.
    vl::Actor* drawLineStrip(const std::vector<vl::dvec2>& ln)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(ln);
      // generate texture coords
      generateLinearTexCoords(geom.get());
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_LINE_STRIP, 0, ln.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a closed line passing through the points defined by 'ln'.
    vl::Actor* drawLineLoop(const std::vector<vl::dvec2>& ln)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(ln);
      // generate texture coords
      generateLinearTexCoords(geom.get());
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_LINE_LOOP, 0, ln.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a convex polygon whose corners are defined by 'poly'
    vl::Actor* fillPolygon(const std::vector<vl::dvec2>& poly)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(poly);
      // generate texture coords
      generatePlanarTexCoords(geom.get(), poly);
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_POLYGON, 0, poly.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a set of triangles. The 'triangles' parameters must contain N triplets of vl::dvec2. Each triplet defines a triangle.
    vl::Actor* fillTriangles(const std::vector<vl::dvec2>& triangles)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(triangles);
      // generate texture coords
      generatePlanarTexCoords(geom.get(), triangles);
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_TRIANGLES, 0, triangles.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a triangle fan.
    vl::Actor* fillTriangleFan(const std::vector<vl::dvec2>& fan)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(fan);
      // generate texture coords
      generatePlanarTexCoords(geom.get(), fan);
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_TRIANGLE_FAN, 0, fan.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a strip of triangles as defined by the OpenGL primitive GL_TRIANGLE_STRIP.
    vl::Actor* fillTriangleStrip(const std::vector<vl::dvec2>& strip)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(strip);
      // generate texture coords
      generatePlanarTexCoords(geom.get(), strip);
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_TRIANGLE_STRIP, 0, strip.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a set of rectangles as defined by the OpenGL primitive GL_QUADS
    vl::Actor* fillQuads(const std::vector<vl::dvec2>& quads)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(quads);
      // generate texture coords
      generateQuadsTexCoords(geom.get(), quads);
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_QUADS, 0, quads.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a set of rectangles as defined by the OpenGL primitive GL_QUAD_STRIP
    vl::Actor* fillQuadStrip(const std::vector<vl::dvec2>& quad_strip)
    {
      // fill the vertex position array
      vl::ref<vl::Geometry> geom = prepareGeometry(quad_strip);
      // generate texture coords
      generatePlanarTexCoords(geom.get(), quad_strip);
      // issue the primitive
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_QUAD_STRIP, 0, quad_strip.size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders a single point. This is only an utility function. If you want to draw many points use drawPoints(const std::vector<vl::dvec2>& pt) instead.
    vl::Actor* drawPoint(double x, double y)
    {
      std::vector<vl::dvec2> pt;
      pt.push_back(vl::dvec2(x,y));
      return drawPoints(pt);
    }
    //! Renders a set of points using the currently set pointSize(), color() and image().
    vl::Actor* drawPoints(const std::vector<vl::dvec2>& pt)
    {
      // transform the points
      vl::ref<vl::ArrayFVec3> pos_array = new vl::ArrayFVec3;
      pos_array->resize(pt.size());
      // transform done using high precision
      for(unsigned i=0; i<pt.size(); ++i)
      {
        pos_array->at(i) = (vl::fvec3)(matrix() * vl::dvec3(pt[i].x(), pt[i].y(), 0));
        // needed for pixel/perfect rendering
        if (mState.mPointSize % 2 == 0)
        {
          pos_array->at(i).s() += 0.5;
          pos_array->at(i).t() += 0.5;
        }
      }
      // generate geometry
      vl::ref< vl::Geometry > geom = new vl::Geometry;
      geom->setVertexArray(pos_array.get());
      geom->primitives()->push_back( new vl::DrawArrays(vl::PT_POINTS, 0, pos_array->size()) );
      // add the actor
      return addActor( new vl::Actor(geom.get(), currentEffect(), NULL) );
    }
    //! Renders the outline of an ellipse.
    vl::Actor* drawEllipse(double origx, double origy, double xaxis, double yaxis, int segments = 64)
    {
      std::vector<vl::dvec2> points;
      points.resize(segments);
      for(int i=0; i<segments; ++i)
      {
        double t = (double)i/(segments-1) * vl::dPi * 2.0 + vl::dPi * 0.5;
        points[i] = vl::dvec2(cos(t)*xaxis*0.5+origx, sin(t)*yaxis*0.5+origy);
      }
      return drawLineStrip(points);
    }
    //! Renders an ellipse.
    vl::Actor* fillEllipse(double origx, double origy, double xaxis, double yaxis, int segments = 64)
    {
      std::vector<vl::dvec2> points;
      points.resize(segments);
      for(int i=0; i<segments; ++i)
      {
        double t = (double)i/segments * vl::dPi * 2.0 + vl::dPi * 0.5;
        points[i] = vl::dvec2(cos(t)*xaxis*0.5+origx, sin(t)*yaxis*0.5+origy);
      }
      return fillPolygon(points);
    }
    //! Utility function that renders the outline of a quad.
    vl::Actor* drawQuad(double left, double bottom, double right, double top)
    {
      std::vector<vl::dvec2> quad;
      quad.push_back(vl::dvec2(left,bottom));
      quad.push_back(vl::dvec2(left,top));
      quad.push_back(vl::dvec2(right,top));
      quad.push_back(vl::dvec2(right,bottom));
      return drawLineLoop(quad);
    }
    //! Utility function that renders a single quad.
    vl::Actor* fillQuad(double left, double bottom, double right, double top)
    {
      std::vector<vl::dvec2> quad;
      quad.push_back(vl::dvec2(left,bottom));
      quad.push_back(vl::dvec2(left,top));
      quad.push_back(vl::dvec2(right,top));
      quad.push_back(vl::dvec2(right,bottom));
      return fillQuads(quad);
    }

    /**
     * Starts the drawing process. You have to call this function before calling any of the fill* and draw* functions.
     * This function will erase all the previously generated content of the VectorGraphics.
     */
    void startDrawing()
    {
      clear();
    }

    /** 
     * Continues the rendering on a VectorGraphics object. This function will reset the VectorGraphics state and matrix but will not 
     * erase the previously generated graphics.
     */
    void continueDrawing()
    {
      /*mActors.clear();*/ // keep the currently drawn actors

      /*mVGToEffectMap.clear();*/      // keeps cached resources
      /*mImageToTextureMap.clear();*/  // keeps cached resources
      /*mRectToScissorMap.clear();*/   // keeps cached resources

      // restore the default states
      mState  = State();
      mMatrix = vl::dmat4();
      mMatrixStack.clear();
      mStateStack.clear();
    }

    //! Ends the rendering on a VectorGraphics and releases the resources used during the Actor generation process. 
    //! If you intend to continue the rendering or to add new graphics objects later set 'release_cache' to false.
    void endDrawing(bool release_cache=true)
    {
      if (release_cache)
      {
        mVGToEffectMap.clear();
        mImageToTextureMap.clear();
        mRectToScissorMap.clear();
      }
      /*mState  = State();
      mMatrix = vl::dmat4();*/
      mMatrixStack.clear();
      mStateStack.clear();
    }

    //! Resets the VectorGraphics removing all the graphics objects and resetting its internal state.
    void clear()
    {
      // remove all the actors
      mActors.clear();

      // reset everything
      mVGToEffectMap.clear();
      mImageToTextureMap.clear();
      mRectToScissorMap.clear();

      // restore the default states
      mState  = State();
      mMatrix = vl::dmat4();
      mMatrixStack.clear();
      mStateStack.clear();
    }

    //! The current color. Note that the current color also modulates the currently active image.
    void setColor(const vl::fvec4& color) { mState.mColor = color; }
    //! The current color. Note that the current color also modulates the currently active image.
    const vl::fvec4& color() const { return mState.mColor; }

    //! The current point size
    void setPointSize(int size) { mState.mPointSize = size; }
    //! The current point size
    int pointSize() const { return mState.mPointSize; }

    //! The current image used to texture the rendered objects. Note that the current color also modulates the currently active image.
    void setImage(vl::Image* image) { mState.mImage = image; }
    //! The current image used to texture the rendered objects. Note that the current color also modulates the currently active image.
    const vl::Image* image() const { return mState.mImage.get(); }
    //! The current image used to texture the rendered objects. Note that the current color also modulates the currently active image.
    vl::Image* image() { return mState.mImage.get(); }

    //! Utility function equivalent to 'setImage(image); setPointSize(image->width());'
    void setPoint(vl::Image* image) { setImage(image); setPointSize(image->width()); }

    //! The current texture mode
    void setTextureMode(ETextureMode mode) { mState.mTextureMode = mode; }
    //! The current texture mode
    ETextureMode textureMode() const { return mState.mTextureMode; }

    //! The current logic operation, see also http://www.opengl.org/sdk/docs/man/xhtml/glLogicOp.xml for more information.
    void setLogicOp(vl::ELogicOp op) { mState.mLogicOp = op; }
    //! The current logic operation
    vl::ELogicOp logicOp() const { return mState.mLogicOp; }

    //! The current line width, see also http://www.opengl.org/sdk/docs/man/xhtml/glLineWidth.xml for more information.
    void setLineWidth(float width) { mState.mLineWidth = width; }
    //! The current line width
    float lineWidth() const { return mState.mLineWidth; }

    //! The current point smoothing mode
    void setPointSmoothing(bool smooth) { mState.mPointSmoothing = smooth; }
    //! The current point smoothing mode
    bool pointSmoothing() const { return mState.mPointSmoothing; }

    //! The current line smoothing mode
    void setLineSmoothing(bool smooth) { mState.mLineSmoothing = smooth; }
    //! The current line smoothing mode
    bool lineSmoothing() const { return mState.mLineSmoothing; }

    //! The current polygon smoothing mode
    void setPolygonSmoothing(bool smooth) { mState.mPolygonSmoothing = smooth; }
    //! The current polygon smoothing mode
    bool polygonSmoothing() const { return mState.mPolygonSmoothing; }

    //! The current line stipple, see also http://www.opengl.org/sdk/docs/man/xhtml/glLineStipple.xml for more information.
    void setLineStipple(ELineStipple stipple) 
    {
      switch(stipple)
      {
        case LineStipple_Solid: mState.mLineStipple = 0xFFFF; break;
        case LineStipple_Dot:   mState.mLineStipple = 0xAAAA; break;
        case LineStipple_Dash:  mState.mLineStipple = 0xCCCC; break;
        case LineStipple_Dash4: mState.mLineStipple = 0xF0F0; break;
        case LineStipple_Dash8: mState.mLineStipple = 0xFF00; break;
        case LineStipple_DashDot: mState.mLineStipple = 0xF840; break;
        case LineStipple_DashDotDot: mState.mLineStipple = 0xF888; break;
      }
    }
    //! The current line stipple
    void setLineStipple(unsigned short stipple) { mState.mLineStipple = stipple; }
    //! The current line stipple
    unsigned short lineStipple() const { return mState.mLineStipple; }

    //! The current polygon stipple, see also http://www.opengl.org/sdk/docs/man/xhtml/glPolygonStipple.xml for more information.
    void setPolygonStipple(EPolygonStipple stipple) 
    {
      unsigned char solid_stipple[] = {
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF };
      unsigned char hline_stipple[] = {
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 
        0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00 };
      unsigned char vline_stipple[] = {
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA };
      unsigned char chain_stipple[] = {
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 0xAA,0xAA,0xAA,0xAA, 
        0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55, 0x55,0x55,0x55,0x55 };
      unsigned char dot_stipple[] = {
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 
        0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55, 0xAA,0xAA,0xAA,0xAA, 0x55,0x55,0x55,0x55 };
      switch(stipple)
      {
        case PolygonStipple_Solid: setPolygonStipple(solid_stipple); break;
        case PolygonStipple_Dot: setPolygonStipple(dot_stipple); break;
        case PolygonStipple_Chain: setPolygonStipple(chain_stipple); break;
        case PolygonStipple_HLine: setPolygonStipple(hline_stipple); break;
        case PolygonStipple_VLine: setPolygonStipple(vline_stipple); break;
      }
    }
    //! The current polygon stipple
    void setPolygonStipple(unsigned char* stipple) { memcpy(mState.mPolyStipple, stipple, 32*32/8); }
    //! The current polygon stipple
    const unsigned char* polygonStipple() const { return mState.mPolyStipple; }
    //! The current polygon stipple
    unsigned char* polygonStipple() { return mState.mPolyStipple; }

    //! The current alpha function, see also http://www.opengl.org/sdk/docs/man/xhtml/glAlphaFunc.xml for more information.
    void setAlphaFunc(vl::EFunction func, float ref_value)   { mState.mAlphaFuncRefValue=ref_value; mState.mAlphaFunc=func; }
    //! The current alpha function
    void getAlphaFunc(vl::EFunction& func, float& ref_value) const { ref_value=mState.mAlphaFuncRefValue; func=mState.mAlphaFunc; }

    //! The current blending factor, see also http://www.opengl.org/sdk/docs/man/xhtml/glBlendFunc.xml for more information.
    void setBlendFunc(vl::EBlendFactor src_rgb, vl::EBlendFactor dst_rgb, vl::EBlendFactor src_alpha, vl::EBlendFactor dst_alpha)
    {
      mState.mBlendFactorSrcRGB   = src_rgb;
      mState.mBlendFactorDstRGB   = dst_rgb;
      mState.mBlendFactorSrcAlpha = src_alpha;
      mState.mBlendFactorDstAlpha = dst_alpha;
    }
    //! The current blending factor
    void getBlendFunc(vl::EBlendFactor& src_rgb, vl::EBlendFactor& dst_rgb, vl::EBlendFactor& src_alpha, vl::EBlendFactor& dst_alpha) const
    {
      src_rgb   = mState.mBlendFactorSrcRGB;
      dst_rgb   = mState.mBlendFactorDstRGB;
      src_alpha = mState.mBlendFactorSrcAlpha;
      dst_alpha = mState.mBlendFactorDstAlpha;
    }

    //! The current blend equation, see also http://www.opengl.org/sdk/docs/man/xhtml/glBlendEquation.xml for more information.
    void setBlendEquation( vl::EBlendEquation rgb_eq, vl::EBlendEquation alpha_eq ) 
    {
      mState.mBlendEquationRGB   = rgb_eq;
      mState.mBlendEquationAlpha = alpha_eq;
    }
    //! The current blend equation.
    void getBlendEquation( vl::EBlendEquation& rgb_eq, vl::EBlendEquation& alpha_eq ) const
    {
      rgb_eq   = mState.mBlendEquationRGB;
      alpha_eq = mState.mBlendEquationAlpha;
    }

    //! The current color mask, see also http://www.opengl.org/sdk/docs/man/xhtml/glColorMask.xml for more information.
    void setColorMask(bool r, bool g, bool b, bool a) { mState.mColorMask = vl::ivec4(r?1:0,g?1:0,b?1:0,a?1:0); }
    //! The current color mask.
    const vl::ivec4& colorMask() const { return mState.mColorMask; }

    /*void setDetphMask(bool mask) { mState.mDepthMask = mask; }
    bool depthMask() const { return mState.mDepthMask; }*/

    //! If set to 'true' the stencil test and operations will be enabled
    void setStencilTestEnabled(bool enabled) { mState.mStencilTestEnabled = enabled; }
    //! If set to 'true' the stencil test and operations will be enabled
    bool stencilTestEnabled() const { return mState.mStencilTestEnabled; }

    //! Current stencil mask, see also http://www.opengl.org/sdk/docs/man/xhtml/glStencilMask.xml for more information.
    void setStencilMask(unsigned int mask) { mState.mStencilMask = mask; }
    //! Current stencil mask.
    unsigned int stencilMask() const { return mState.mStencilMask; }

    //! Current stencil operation, see also http://www.opengl.org/sdk/docs/man/xhtml/glStencilOp.xml for more information.
    void setStencilOp(vl::EStencilOp sfail, vl::EStencilOp dpfail, vl::EStencilOp dppass)
    {
      mState.mStencil_SFail  = sfail;
      mState.mStencil_DpFail = dpfail;
      mState.mStencil_DpPass = dppass;
    }
    //! Current stencil operation.
    void getStencilOp(vl::EStencilOp& sfail, vl::EStencilOp& dpfail, vl::EStencilOp& dppass)
    {
      sfail  = mState.mStencil_SFail;
      dpfail = mState.mStencil_DpFail;
      dppass = mState.mStencil_DpPass;
    }

    //! The current stencil function, see also http://www.opengl.org/sdk/docs/man/xhtml/glStencilFunc.xml for more information.
    void setStencilFunc(vl::EFunction func, int refval, unsigned int mask)
    {
      mState.mStencil_Function     = func;
      mState.mStencil_RefValue     = refval;
      mState.mStencil_FunctionMask = mask;
    }
    //! The current stencil function.
    void getStencilFunc(vl::EFunction& func, int& refval, unsigned int& mask)
    {
      func   = mState.mStencil_Function;
      refval = mState.mStencil_RefValue;
      mask   = mState.mStencil_FunctionMask;
    }

    //! Sets the current Font
    void setFont(const vl::String& name, int size, bool smooth=false) { mState.mFont = vl::VisualizationLibrary::fontManager()->acquireFont(name,size,smooth); }
    //! Sets the current Font
    void setFont(const vl::Font* font) { setFont(font->filePath(),font->size(),font->smooth()); }
    //! Sets the default Font
    void setDefaultFont() { setFont(vl::VisualizationLibrary::fontManager()->acquireFont("/font/bitstream-vera/VeraMono.ttf", 10, false)); }
    //! Returns the current Font
    const vl::Font* font() const { return mState.mFont.get(); }

    /**
     * Defines the scissor box and enables the scissor test.
     * The parameters are considered in windows coordinates.
     * The Scissor is used to clip the rendering against a specific rectangular area.
     * See also http://www.opengl.org/sdk/docs/man/xhtml/glScissor.xml for more information.
     */
    void setScissor(int x, int y, int width, int height)
    {
      mScissor = resolveScissor(x,y,width,height);
    }
    /**
     * Returns the currently active Scissor
     */
    const vl::Scissor* scissor() const { return mScissor.get(); }
    /**
     * Disables the Scissor test and clipping.
     */
    void removeScissor()
    {
      mScissor = NULL;
    }

    /**
     * Clears the specific area of the viewport. 
     * The parameters x y w h define a rectangular area in viewport coordinates that is clipped against the viewport itself.
     * 
     * \note The specified rectangular area is not affected by the current matrix transform.
     */
    vl::Actor* clearColor(const vl::fvec4& color, int x=0, int y=0, int w=-1, int h=-1)
    {
      vl::ref<vl::Clear> clear = new vl::Clear;
      clear->setClearColorBuffer(true);
      clear->setClearColorValue(color);
      clear->setScissorBox(x,y,w,h);
      return addActor( new vl::Actor( clear.get(), /*mDefaultEffect.get()*/currentEffect(), NULL) );
    }

    /** 
     * Clears the specific area of the viewport. 
     * The parameters x y w h define a rectangular area in viewport coordinates that is clipped against the viewport itself.
     *
     * \note The specified rectangular area is not affected by the current matrix transform.
     */
    vl::Actor* clearStencil(int clear_val, int x=0, int y=0, int w=-1, int h=-1)
    {
      vl::ref<vl::Clear> clear = new vl::Clear;
      clear->setClearStencilBuffer(true);
      clear->setClearStencilValue(clear_val);
      clear->setScissorBox(x,y,w,h);
      return addActor( new vl::Actor( clear.get(), /*mDefaultEffect.get()*/currentEffect(), NULL) );
    }

    //! Draw the specified Text object
    vl::Actor* drawText(vl::Text* text)
    {
      if (text->font() == NULL)
        text->setFont(mState.mFont.get());
      return addActor( new vl::Actor(text, /*mDefaultEffect.get()*/currentEffect(), NULL) );
    }

    /**
     * Draws the specified text at the specified position.
     * Note that the current matrix transform affect the final position, rotation and scaling of the text.
     */
    vl::Actor* drawText(int x, int y, const vl::String& text, int alignment = vl::AlignBottom|vl::AlignLeft)
    {
      pushMatrix();
      mMatrix = vl::dmat4::translation(x,y,0) * mMatrix;
      vl::Actor* act = drawText(text, alignment);
      popMatrix();
      return act;
    }

    //! Draws the specified text
    vl::Actor* drawText(const vl::String& text, int alignment = vl::AlignBottom|vl::AlignLeft)
    {
      vl::ref<vl::Text> t = new vl::Text;
      t->setText( text );
      t->setAlignment(alignment);
      t->setViewportAlignment(vl::AlignBottom|vl::AlignLeft);
      t->setColor( mState.mColor );
      t->setMatrix( (vl::fmat4)matrix() );
      return drawText(t.get());
    }
    /** Draws the specified Actor with the specified Transform.
     * If keep_effect is set to 'false' or the Actor's Effect is NULL a default Effect is automatically generated.
     * If 'transform' is non NULL it is bound to the Actor.
     */
    vl::Actor* drawActor(vl::Actor* actor, vl::Transform* transform=NULL, bool keep_effect=false)
    {
      VL_CHECK(actor->effect())
      if (!keep_effect || !actor->effect())
        actor->setEffect(currentEffect());
      if (transform != NULL)
        actor->setTransform(transform);
      return addActor(actor);
    }
    /** 
     * Like drawActor() but instead of drawing the given actor creates a copy of it and draws that. 
     * This function is useful when you want to crate multiple instances of the same geometry.
    */
    vl::Actor* drawActorCopy(vl::Actor* actor, vl::Transform* transform=NULL)
    {
      vl::ref<vl::Actor> copy = new vl::Actor(*actor);
      copy->setTransform(transform);
      drawActor(copy.get());
      return copy.get();
    }

    //! Returns the current transform matrix
    const vl::dmat4& matrix() const { return mMatrix; }
    //! Sets the current transform matrix
    void setMatrix(const vl::dmat4& matrix) { mMatrix = matrix; }
    //! Resets the current transform matrix.
    void resetMatrix() { mMatrix.setIdentity(); }
    //! Performs a rotation of 'deg' degrees around the z axis.
    void rotate(double deg) 
    { 
      mMatrix = mMatrix * vl::dmat4::rotation(deg, 0,0,1.0); 
    }
    //! Translates the current transform matrix
    void translate(double x, double y, double z=0.0) 
    { 
      mMatrix = mMatrix * vl::dmat4::translation(x,y,z); 
    }
    //! Scales the current transform matrix
    void scale(double x, double y, double z=1.0) 
    { 
      mMatrix = mMatrix * vl::dmat4::scaling(x,y,z); 
    }

    //! Pushes the current matrix in the matrix stack in order to restore it later with popMatrix().
    void pushMatrix() { mMatrixStack.push_back(matrix()); }
    //! Pops the top most matrix in the matrix stack and sets it as the current matrix.
    void popMatrix() 
    { 
      if (mMatrixStack.empty())
      {
        vl::Log::error("VectorGraphics::popMatrix() matrix stack underflow!\n");
        return;
      }
      setMatrix(mMatrixStack.back());
      mMatrixStack.pop_back();
    }
    //! Returns the matrix stack.
    const std::vector<vl::dmat4>& matrixStack() const { return mMatrixStack; }

    //! Pushes the current VectorGraphics state (including the matrix state) in the state stack in order to restore it later with popState().
    void pushState() 
    { 
      mStateStack.push_back(mState); 
      pushMatrix();
    }
    //! Pops the top most state in the state stack and sets it as the current state.
    void popState() 
    { 
      popMatrix();
      if (mStateStack.empty())
      {
        vl::Log::error("VectorGraphics::popState() matrix stack underflow!\n");
        return;
      }
      mState = mStateStack.back();
      mStateStack.pop_back();
    }
    /*const std::vector<State>& stateStack() const { return mStateStack; }*/

    /**
     * Pushes the current scissor in the scissor stack in order to restore it later with popScissor() and activates a new one.
     * The 'x', 'y', 'w' and 'h' parameters define the new scissor rectangle. 
     * Note that such rectangle is clipped against the currently active one.
     */
    void pushScissor(int x, int y, int w, int h) 
    {
      mScissorStack.push_back(mScissor.get()); 
      vl::RectI newscissor = mScissor ? mScissor->scissorRect().intersected(vl::RectI(x,y,w,h)) : vl::RectI(x,y,w,h);
      setScissor(newscissor.x(), newscissor.y(), newscissor.width(), newscissor.height());
    }
    //! Pops the top most scissor in the scissor stack and sets it as the current scissor.
    void popScissor() 
    { 
      if (mScissorStack.empty())
      {
        vl::Log::error("VectorGraphics::popScissor() scissor stack underflow!\n");
        return;
      }
      mScissor = mScissorStack.back();
      mScissorStack.pop_back();
    }
    //! Returns the scissor stack.
    const std::vector< vl::ref<vl::Scissor> >& scissorStack() const { return mScissorStack; }

    //! Binds the given Transform to all the Actor[s] that have been generated so far.
    void setTransform(vl::Transform* transform) { for(int i=0; i<actors()->size(); ++i) actors()->at(i)->setTransform(transform); }

    //! Returns the Effect representing the current VectorGraphic's state.
    vl::Effect* currentEffect() { return currentEffect(mState); }

  private:
    void generateQuadsTexCoords(vl::Geometry* geom, const std::vector<vl::dvec2>& points)
    {
      // generate only if there is an image active
      if (mState.mImage)
      {
        vl::ref<vl::ArrayFVec2> tex_array = new vl::ArrayFVec2;
        tex_array->resize(geom->vertexArray()->size());
        geom->setTexCoordArray(0, tex_array.get());
        if (mState.mTextureMode == TextureMode_Clamp)
        {
          float du = 1.0f / mState.mImage->width()  / 2.0f;
          float dv = mState.mImage->height() ? (1.0f / mState.mImage->height() / 2.0f) : 0.5f;
          //  1----2
          //  |    |
          //  |    |
          //  0    3
          vl::fvec2 texc[] = { vl::fvec2(du,dv), vl::fvec2(du,1.0f-dv), vl::fvec2(1.0f-du,1.0f-dv), vl::fvec2(1.0f-du,dv) };
          for(unsigned i=0; i<points.size(); ++i)
          {
            float s = texc[i%4].s();
            float t = texc[i%4].t();
            tex_array->at(i).s() = s;
            tex_array->at(i).t() = t;
          }
        }
        else
        {
          vl::AABB aabb;
          for(unsigned i=0; i<points.size(); ++i)
            aabb.addPoint( (vl::vec3)geom->vertexArray()->vectorAsVec4(i).xyz() );
          for(unsigned i=0; i<points.size(); ++i)
          {
            vl::vec4 v = geom->vertexArray()->vectorAsVec4(i);
            double s = (geom->vertexArray()->vectorAsVec4(i).s()-aabb.minCorner().s()) / (mState.mImage->width() );
            double t = (geom->vertexArray()->vectorAsVec4(i).t()-aabb.minCorner().t()) / (mState.mImage->height());
            tex_array->at(i).s() = (float)s;
            tex_array->at(i).t() = (float)t;
          }
        }
      }
    }

    void generatePlanarTexCoords(vl::Geometry* geom, const std::vector<vl::dvec2>& points)
    {
      // generate only if there is an image active
      if (mState.mImage)
      {
        // generate uv coordinates based on the aabb
        vl::ref<vl::ArrayFVec2> tex_array = new vl::ArrayFVec2;
        tex_array->resize(geom->vertexArray()->size());
        geom->setTexCoordArray(0, tex_array.get());
        if (mState.mTextureMode == TextureMode_Clamp)
        {
          // compute aabb
          vl::AABB aabb;
          for(unsigned i=0; i<points.size(); ++i)
            aabb.addPoint( (vl::vec3)vl::dvec3(points[i],0.0) );
          for(unsigned i=0; i<points.size(); ++i)
          {
            float s = float((points[i].x() - aabb.minCorner().x()) / aabb.width() );
            float t = float((points[i].y() - aabb.minCorner().y()) / aabb.height());
            tex_array->at(i).s() = s;
            tex_array->at(i).t() = t;
          }
        }
        else
        {
          vl::AABB aabb;
          for(unsigned i=0; i<points.size(); ++i)
            aabb.addPoint( (vl::vec3)geom->vertexArray()->vectorAsVec4(i).xyz()+vl::vec3(0.5f,0.5f,0.0f) );
          for(unsigned i=0; i<points.size(); ++i)
          {
            vl::vec4 v = geom->vertexArray()->vectorAsVec4(i);
            double s = (geom->vertexArray()->vectorAsVec4(i).s()-aabb.minCorner().s()) / mState.mImage->width();
            double t = (geom->vertexArray()->vectorAsVec4(i).t()-aabb.minCorner().t()) / mState.mImage->height();
            tex_array->at(i).s() = (float)s;
            tex_array->at(i).t() = (float)t;
          }
        }
      }
    }

    void generateLinearTexCoords(vl::Geometry* geom)
    {
      if (mState.mImage)
      {
        vl::ref<vl::ArrayFloat> tex_array = new vl::ArrayFloat;
        tex_array->resize(geom->vertexArray()->size());
        float u1 = 1.0f / mState.mImage->width() * 0.5f;
        float u2 = 1.0f - 1.0f / mState.mImage->width() * 0.5f;
        for(size_t i=0; i<tex_array->size(); ++i)
        {
          float t = (float)i/(tex_array->size()-1);
          tex_array->at(i) = u1 * (1.0f-t) + u2 * t;
        }
        // generate geometry
        geom->setTexCoordArray(0, tex_array.get());
      }
    }

    vl::ref<vl::Geometry> prepareGeometry(const std::vector<vl::dvec2>& ln)
    {
      // transform the lines
      vl::ref<vl::ArrayFVec3> pos_array = new vl::ArrayFVec3;
      pos_array->resize(ln.size());
      // transform done using high precision
      for(unsigned i=0; i<ln.size(); ++i)
        pos_array->at(i) = (vl::fvec3)(matrix() * vl::dvec3(ln[i].x(), ln[i].y(), 0));
      // generate geometry
      vl::ref< vl::Geometry > geom = new vl::Geometry;
      geom->setVertexArray(pos_array.get());
      return geom;
    }

    vl::Scissor* resolveScissor(int x, int y, int width, int height)
    {
      vl::ref<vl::Scissor> scissor = mRectToScissorMap[vl::RectI(x,y,width,height)];
      if (!scissor)
      {
        scissor = new vl::Scissor(x,y,width,height);
        mRectToScissorMap[vl::RectI(x,y,width,height)] = scissor;
      }
      return scissor.get();
    }

    vl::Texture* resolveTexture(vl::Image* image)
    {
      vl::Texture* texture = mImageToTextureMap[ImageState(image,mState.mTextureMode)].get();
      if (!texture)
      {
        texture = new vl::Texture( image, vl::TF_RGBA, true, false);
        texture->getTexParameter()->setMinFilter(vl::TPF_LINEAR_MIPMAP_LINEAR);
        texture->getTexParameter()->setMagFilter(vl::TPF_LINEAR);
        #if 0
          texture->getTexParameter()->setBorderColor(vl::fvec4(1,0,1,1)); // for debuggin purposes
        #else
          texture->getTexParameter()->setBorderColor(vl::fvec4(1,1,1,0)); // transparent white
        #endif
        if (mState.mTextureMode == vlVG::TextureMode_Repeat)
        {
          texture->getTexParameter()->setWrapS(vl::TPW_REPEAT);
          texture->getTexParameter()->setWrapT(vl::TPW_REPEAT);
        }
        else
        {
          texture->getTexParameter()->setWrapS(vl::TPW_CLAMP);
          texture->getTexParameter()->setWrapT(vl::TPW_CLAMP);
        }
        mImageToTextureMap[ImageState(image,mState.mTextureMode)] = texture;
      }
      return texture;
    }

    vl::Effect* currentEffect(const State& vgs)
    {
      vl::Effect* effect = mVGToEffectMap[vgs].get();
      // create a Shader reflecting the current VectorGraphics state machine state
      if (!effect)
      {
        effect = new vl::Effect;
        mVGToEffectMap[vgs] = effect;
        vl::Shader* shader = effect->shader();
        /*shader->disable(vl::EN_DEPTH_TEST);*/
        shader->enable(vl::EN_BLEND);
        // color
        shader->enable(vl::EN_LIGHTING);
        shader->gocMaterial()->setFlatColor(vgs.mColor);
        // point size
        shader->gocPointSize()->set((float)vgs.mPointSize);
        // logicop
        if (vgs.mLogicOp != vl::LO_COPY)
        {
          shader->gocLogicOp()->set(vgs.mLogicOp);
          shader->enable(vl::EN_COLOR_LOGIC_OP);
        }
        // line stipple
        if ( vgs.mLineStipple != 0xFFFF )
        {
          shader->gocLineStipple()->set(1, vgs.mLineStipple);
          shader->enable(vl::EN_LINE_STIPPLE);
        }
        // line width
        if (vgs.mLineWidth != 1.0f)
          shader->gocLineWidth()->set(vgs.mLineWidth);
        // point smooth
        if (vgs.mPointSmoothing)
        {
          shader->gocHint()->setPointSmoothHint(vl::HM_NICEST);
          shader->enable(vl::EN_POINT_SMOOTH);
        }
        // line smooth
        if (vgs.mLineSmoothing)
        {
          shader->gocHint()->setLineSmoothHint(vl::HM_NICEST);
          shader->enable(vl::EN_LINE_SMOOTH);
        }
        // polygon smooth
        if (vgs.mPolygonSmoothing)
        {
          shader->gocHint()->setPolygonSmoohtHint(vl::HM_NICEST);
          shader->enable(vl::EN_POLYGON_SMOOTH);
        }
        // poly stipple
        unsigned char solid_stipple[] = {
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 
          0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF
        };
        if ( memcmp(vgs.mPolyStipple, solid_stipple, 32*32/8) != 0 )
        {
          shader->gocPolygonStipple()->set(vgs.mPolyStipple);
          shader->enable(vl::EN_POLYGON_STIPPLE);
        }
        // blending equation and function
        shader->gocBlendEquation()->set(vgs.mBlendEquationRGB, vgs.mBlendEquationAlpha);
        shader->gocBlendFunc()->set(vgs.mBlendFactorSrcRGB, vgs.mBlendFactorDstRGB, vgs.mBlendFactorSrcAlpha, vgs.mBlendFactorDstAlpha);
        if (vgs.mAlphaFunc != vl::FU_ALWAYS)
        {
          shader->enable(vl::EN_ALPHA_TEST);
          shader->gocAlphaFunc()->set(vgs.mAlphaFunc, vgs.mAlphaFuncRefValue);
        }
        // masks (by default they are all 'true')
        if (vgs.mColorMask != vl::ivec4(1,1,1,1) )
          shader->gocColorMask()->set(vgs.mColorMask.r()?true:false,vgs.mColorMask.g()?true:false,vgs.mColorMask.b()?true:false,vgs.mColorMask.a()?true:false);
        // stencil
        if (vgs.mStencilTestEnabled)
        {
          shader->enable(vl::EN_STENCIL_TEST);
          shader->gocStencilMask()->set(vl::PF_FRONT_AND_BACK, vgs.mStencilMask);
          shader->gocStencilOp()->set(vl::PF_FRONT_AND_BACK, vgs.mStencil_SFail, vgs.mStencil_DpFail, vgs.mStencil_DpPass);
          shader->gocStencilFunc()->set(vl::PF_FRONT_AND_BACK, vgs.mStencil_Function, vgs.mStencil_RefValue, vgs.mStencil_FunctionMask);
        }
        /*if (!vgs.mDepthMask)
          shader->gocDepthMask()->set(false);*/
        // texture
        if (vgs.mImage)
        {
          shader->gocTextureUnit(0)->setTexture( resolveTexture(vgs.mImage.get()) );
          if (GLEW_ARB_point_sprite || GLEW_VERSION_2_0)
          {
            shader->gocTexEnv(0)->setPointSpriteCoordReplace(true);
            shader->enable(vl::EN_POINT_SPRITE);
          }
          else
            vl::Log::error("GL_ARB_point_sprite not supported.\n");
        }
      }
      return effect;
    }

    vl::Actor* addActor(vl::Actor* actor) 
    { 
      actor->setScissor(mScissor.get());
      mActors.push_back(actor);
      return actor;
    }

  private:
    // state-machine state variables
    State mState;
    vl::dmat4 mMatrix;
    vl::ref<vl::Scissor> mScissor;
    std::vector<State> mStateStack;
    std::vector<vl::dmat4> mMatrixStack;
    std::vector< vl::ref<vl::Scissor> > mScissorStack;
    // state-machine state map
    std::map<State, vl::ref<vl::Effect> > mVGToEffectMap;
    std::map<ImageState, vl::ref<vl::Texture> > mImageToTextureMap;
    std::map<vl::RectI, vl::ref<vl::Scissor> > mRectToScissorMap;
    vl::ref<vl::Effect> mDefaultEffect;
    vl::ActorCollection mActors;
  };
//-------------------------------------------------------------------------------------------------------------------------------------------
}

#endif
