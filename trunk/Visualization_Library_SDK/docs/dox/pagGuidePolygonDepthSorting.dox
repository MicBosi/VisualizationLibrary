/**

	\page pagGuidePolygonDepthSorting Transparency and Polygon Depth Sorting Tutorial

	In this tutorial you will learn how to perform primitive depth sorting in order to obtain correct transparencies.
	
	Managing transparent objects in the correct way using OpenGL (but also DirectX) can be quite challenging at times. This is because in general, when rendering transparent objects, the order in which such objects are rendered affects the final result. Theoretically the problem could be solved by sorting back to front each single pixel that is generated by the rendering process. In practice this approach is too expensive to implement and for simple cases it is enough to sort front to back entire objects. This works well util the transparent objects in the scene are convex but when we add concave objects we will start noticing some artifacts. In this cases it is necessary to sort back to font the polygons of each object. When two transparent objects intersect each other, though, not even this approach yelds correct results in general. Fortunately this last case is relatively rare compared to the previous ones.

	<center>
	<table border=0 cellspacing=0 cellpadding=5 width=1%>
	<tr>
		<td> <b>Depth&nbsp;sorting&nbsp;on:</b> </td>
		<td> \image html pagGuidePolygonDepthSorting1a.png </td>
		<td> \image html pagGuidePolygonDepthSorting2a.png </td>
		<td> \image html pagGuidePolygonDepthSorting3a.png </td>
	</tr>
	<tr>
		<td> <b>Depth&nbsp;sorting&nbsp;off:</b> </td>
		<td> \image html pagGuidePolygonDepthSorting1b.png </td>
		<td> \image html pagGuidePolygonDepthSorting2b.png </td>
		<td> \image html pagGuidePolygonDepthSorting3b.png </td>
	</tr>
	</table>
	</center>

	The example below shows how to apply a vl::DepthSortCallback callback to an Actor in order to sort its polygons. In the example we load an object and we display it with and without polygon sorting to hightlight the effect of the vl::DepthSortCallback callback.
	
	The DepthSortCallback class sorts the primitives of the Geometry object bound to the Actor in which the callback is installed.

	This callback in order to work requires the following conditions:
	- The Actor must be bound to a Geometry
	- The bound Geometry must have a Geometry::vertexArray() of type ArrayFloat3
	- Sorts only DrawElementsUInt/UShort/UByte objects with primitive type: PT_POINTS, PT_LINES, PT_TRIANGLES, PT_QUADS

	\remarks

	- The sorting is based on the position of the vertices as specified by Geometry::vertexArray() and for obvious
	reasons cannot take into consideration transformations made in the vertex shader or in the geometry shader.
	- The sorting is performed on a per DrawCall basis. For example, if a Geometry has 2 DrawCall A and B bound to it, then the polygons, lines or points of A will alway be rendered before the ones specified by B. For this reason avoid using Geometry with more than one DrawCall whenever possible to render transparent objects, but rather rearrange each DrawCall in its own Geometry and Actor.
	- vl::DepthSortCallback cannot resolve transparency ordering when two or more transparent objects intersect each other.
	- You need to use vl::DepthSortCallback only when using order-dependent blending (as for the default alpha blending settings). 
	If for example you are using additive blending you would simply set the depth mask to \p false (vl::DepthMask) and enable the depth test (vl::EN_DEPTH_TEST), but you wouldn't need to perform any sorting.

	[From \p App_PolyDepthSorting.cpp]
	\dontinclude App_PolyDepthSorting.cpp
	\skip class
	\until // Have fun!
*/