/**

	\page pagGuideOcclusionCulling OpenGL-Accelerated Occlusion Culling Tutorial

	This tutorial demonstrates how to perform hadware accelerated occlusion culling using the OpenGL extension \p GL_ARB_occlusion_query.
	
	For more information about the OpenGL extension \p GL_ARB_occlusion_query see also http://oss.sgi.com/projects/ogl-sample/registry/ARB/occlusion_query.txt
	
	<center>
	<table border=0 cellspacing=0 cellpadding=5 width=1%>
	<tr>
		<th colspan=4> Sample Foreset Model (1681 trees) - Benchmark on NVIDIA GeForce 8600M GT, Intel Core 2 Duo 2.0GHz </th>
	</tr>
	<tr>
		<td> \image html pagGuideOcclusionCulling1.jpg </td>
		<td> \image html pagGuideOcclusionCulling3.jpg </td>
		<td> \image html pagGuideOcclusionCulling4.jpg </td>
		<td> \image html pagGuideOcclusionCulling2.jpg </td>
	</tr>
	<tr>
		<td valign=top> 
			Large occluder in red: 
			- Occlusion culling off: 7.9 fps.
			- Occlusion culling on: 46.0 fps.
			- \b Speedup: \b 582%
		</td>
		<td valign=top> 
			View of the forest from above:
			- Occlusion culling off: 10.2 fps.
			- Occlusion culling on: 24.8 fps.
			- \b Speedup: \b 243%
		</td>
		<td valign=top> 
			View from under, the ground is a very good occluder:
			- Occlusion culling off: 8.4 fps.
			- Occlusion culling on: 52.0 fps.
			- \b Speedup: \b 620%
		</td>
		<td valign=top> 
			View of the forest from inside: 
			- Occlusion culling off: 8.5 fps.
			- Occlusion culling on: 42.3 fps.
			- \b Speedup: \b 497%
		</td>
	</tr>
	</table>
	</center>
	
	When rendering highly detailed and densely populated scenes most of the rendered geometry is actually hidden by the other objects and geometry which are closer to the camera. This means that a consistent part the GPU time and computational power is spent to render objects that will not be visible in the final rendering. Consider for example a dense forest with thousands of trees. The trees that are close to the camera will have a high chance to be visible but the ones that are far away from the camera will probably not be visible due to the fact that the close ones \p occlude a significant part of the view. The term \p "occlusion culling" refers to a set of techniques that try to exploit this fact. By detecting in advance which objects will be occluded and thus invisible, we can avoid rendering objects that will not significantly contribute to the scene, potentially obtaining a dramatic rendering boost as seen from the figures above.

	\par Drawbacks

The OpenGL extension \p GL_ARB_occlusion_query allows a program to request if a given object will contribute or not to the final rendering providing a huge potential in terms of rendering performances increase as we have seen. Unfortunately this technique has also some drawbacks due to the way the GPU and CPU collaborate, the most important being the fact that once you requested this occlusion visibility check, the OpenGL driver cannot reply before having executed all the OpenGL commands that precede such request. For this reason in order to maximize the CPU/GPU concurrency (and with it the rendering performances) Visualization Library waits one rendering frame before checking the result of the occlusion queries. This means that at any given frame the result of such query actually refers to the position that the camera and the objects had relative to each other in the previous frame. As a result of this occasional flickers might occur when an invisible object becomes visible especially when the camera or such object is moving fast compared to the rendering refresh rate. An example of such problem is shown below.
	
	\image html pagGuideOcclusionCulling_Error.jpg
	
	In the image above the camera is quickly moving to the left uncovering a part of the trees that in the preceding frame were covered by the red occluder. Such trees weren't visible in the previous frame and are thus not rendered in the current frame producing a temporary "hole" in the forest. Note that such "hole" lasts for a single rendering frame but potentially new holes might occur while the camera continues its movement.
	
	Artifacts like this might be more or less noticeable based on the kind of scene rendered and based on the refresh rate of the rendering. For example, it is very easy to notice this effect at 10 fps, but is much more difficult if not impossible to notice them at let say 160 fps.
	
	Note that requesting the result of an occlusion query in the same frame in which it is issued is not an option as this would not only kill the GPU/CPU concurrency but would also cause a vicious cpu-stall/gpu-starvation circle that would result in unacceptable performances even for simple scenes.

	\par Enabling Occlusion Culling

	Exploiting the huge potential of OpenGL accelerated occlusion culling with Visualization Library is extremely simple provided you pay attention to a few details. 
	
	- To enable the occlusion culling you set a simple flag using the method vl::Renderer::setOcclusionCullingEnabled(). This will enable the occlusion culling for all the vl::Actor[s] rendered from then on.
	- Enabling the occlusion culling though is not enough. In order to maximize its efficiency we need to render the solid (non translucent) objects in front-to-back order, that is, we first render the close ones and then the ones far away to maximize the chance of culling away as many objects as possible. In order to do this we will install a special vl::RenderQueueSorter called vl::RenderQueueSorterOcclusion using the method vl::Rendering::setRenderQueueSorter().
	
	\par Large Occluders

In order to be sure to maximize the efficiency of the occlusion culling you want to make sure that large occluders are rendered before all the other objects. In our case for example we assign a rendering rank of -1 to the ground vl::Actor. You should always pay particular attention to very large occluders like the ground vl::Actor in our scene. In fact the vl::RenderQueueSorterOcclusion sorts the vl::Actor[s] based on the distance between the camera and their center. This means that a very large occluder might actually be in front of all the other objects but its center might be further away. Consider for example the image below:

	\image html pagGuideOcclusionCulling_LargeOccluders.png

	The red dot on the left represents the camera, the gray object is a large occluder, the boxes are other objects occluded by the large gray one. As we can see if we simply render the objects in front to back order based on their centers we end up rendering first the red boxes (thus wasting time since they will not be visible!), then the large gray occluder which overdraws the red boxes when rendered on the screen, and then the green boxes (which are actually not rendered thanks to the occlusion culling). With this approach we rendered six boxes (the red ones) which are actually not visible. To optimize this case we would render the gray occluder for first, specifying for it a render rank lower than the boxes' render rank. Remember that the user specified ordering (Actor render rank and render block and Effect render rank) always wins against any eventual automatic sorting performed by a vl::RenderQueueSorter.

	Also keep in mind that the concept of "large occluder" is heavily subjective as a skyscraper seen from 1 Km away is not a good occluder while a matchbox seen from very close can become a very good one!

	[From \p App_OcclusionCulling.hpp]
	\dontinclude App_OcclusionCulling.hpp
	\skip class
	\until // Have fun!
*/